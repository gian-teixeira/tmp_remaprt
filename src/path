remap.c:	if(rmp->startttl > path_length(rmp->path)) goto out_length;
remap.c:	struct pathhop *hop = remap_get_hop(rmp, rmp->startttl);
remap.c:	while(pathhop_is_star(hop) && rmp->startttl > 0) {
remap.c:		rmp->startttl--;
remap.c:		hop = remap_get_hop(rmp, rmp->startttl);
remap.c:	int ttl = path_search_hop(rmp->path, hop, 0);
remap.c:	if(ttl == rmp->startttl) {
remap.c:		remap_local(rmp, rmp->startttl, 0, 1);
remap.c:		remap_binary(rmp, 0, rmp->startttl);
remap.c:			path_search_hop(rmp->path, hop, 0) == -1);
remap.c:	int p1branch = path_search_hop(rmp->path, hop, 0);
remap.c:		if(pathhop_contains_ip(hop, path_dst(rmp->path))) {
remap.c:			path_search_hop(rmp->path, hop, 0) < p1branch) &&
remap.c:		int p1join = path_search_hop(rmp->path, hop, 0);
remap.c:		rmp->shifts[join] = join - p1join;
remap.c:	for(int i = branch+1; i < join; i++) rmp->shifts[i] = RMP_SHIFT_CHANGE;
remap.c:	if(rmp->shifts[branch] != branch - p1branch) {
remap.c:		/* set rmp->shifts */
remap.c:		int p1ttl = path_search_hop(rmp->path, hop, 0);
remap.c:				i, p1ttl, rmp->shifts[i]);
remap.c:		if((i - p1ttl) == rmp->shifts[i]) {
remap.c:	hop = probedb_find_hop(rmp->db, r);
remap.c:	int shift = r - path_search_hop(rmp->path, hop, 0);
remap.c:	for(int i = r; i <= right_boundary; i++) rmp->shifts[i] = shift;
remap.c:	for(hop = pavl_t_first(&trav, rmp->db->hops); hop;
remap.c:		assert(rmp->shifts[ttl] != RMP_SHIFT_CHANGE);
remap.c:		int true_shift = ttl - path_search_hop(rmp->path, hop, 0);
remap.c:		if(true_shift != rmp->shifts[ttl]) {
remap.c:	rmp->path = path_create_copy(opts->path);
remap.c:	if(!rmp->path) goto out;
remap.c:	rmp->db = probedb_create();
remap.c:	if(!rmp->db) goto out_path;
remap.c:	rmp->prober = prober_create(opts,
remap.c:	if(!rmp->prober) goto out_db;
remap.c:	rmp->tq = tqueue_create();
remap.c:	if(!rmp->tq) goto out_prober;
remap.c:	rmp->startttl = opts->ttl - 1;
remap.c:	rmp->total_probes_sent = 0;
remap.c:	memset(rmp->shifts, 0, MAX_PATH_LENGTH*sizeof(int));
remap.c:	prober_destroy(rmp->prober);
remap.c:	probedb_destroy(rmp->db);
remap.c:	path_destroy(rmp->path);
remap.c:	path_destroy(rmp->path);
remap.c:	probedb_destroy(rmp->db);
remap.c:	prober_destroy(rmp->prober);
remap.c:	tqueue_destroy(rmp->tq);
remap.c:	if(!inet_ntop(AF_INET, path_srcptr(rmp->path), src, INET_ADDRSTRLEN)) {
remap.c:	if(!inet_ntop(AF_INET, path_dstptr(rmp->path), dst, INET_ADDRSTRLEN)) {
remap.c:	struct pathhop *rmphop = pavl_t_first(&trav, rmp->db->hops);
remap.c:	for(int i = 0; i < path_length(rmp->path); i++) {
remap.c:			strhop = pathhop_get_hop(rmp->path, i);
remap.c:	snprintf(buf, PATH_STR_BUF, "%d %s %s %d %s", rmp->total_probes_sent,
remap.c:	struct pathhop *hop = probedb_find_hop(rmp->db, ttl);
remap.c:		prober_remap_hop(rmp->prober, ttl+1);
remap.c:		struct pathhop * newhop = tqrecv(rmp->tq);
remap.c:		hop = probedb_add_hop(rmp->db, newhop);
remap.c:	rmp->total_probes_sent += nprobes;
remap.c:	tqsend(rmp->tq, hop);
remap.c:	/* probedb_add_iface(rmp->db, iface); iface_destroy(iface); */
