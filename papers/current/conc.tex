\section{Conclusions and future work}
\label{sec:conc}

In this paper we have shown that path changes in the Internet are
typically local and involve few hops.  We proposed local remapping, a
mechanism that receives the previous route and a change detection point
to efficiently remap the new route.  Local remapping first locates a
local change zone using binary search in the route, then locally remaps
the change.  We have extended \dtrack{}, our system to track path
changes, with local remapping.

Our evaluation with trace-driven simulations and in PlanetLab shows that
local remapping significantly decreases probing cost (75\% overall
reduction in the real deployment), is almost as accurate as complete
remapping (92\% of measurements are identical), and is practical for use
in real systems.  Probing savings can be used to monitor more paths and
improve network coverage, increase probing frequency to improve change
tracking, or use more elaborate probing tools (e.g., using the IP Record
Route option).

As future work, we want to identify path features that allow us to
predict if two paths share a given local change zone.  This would allow
\dtrack{} to remap a local change zone once, then recompute other paths
sharing the same local change zone immediately, without spending probes
to detect or remap the change.

\begin{algorithm}[h]

\KwIn{radii $r_\mathrm{up} \le r_d$ and $r_\mathrm{down} \ge r_c$}

\textbf{if} $r_\mathrm{up} \ge r_\mathrm{down}$\textbf{: return}

$r \leftarrow (r_\mathrm{up} + r_\mathrm{down})/2$\textbf{,} measure($r$)

\textbf{if} $r_d < r < r_c$\textbf{:} remap($r$)

\textbf{else if} $r \le r_d$\textbf{:} search($r$, $r_\textrm{down}$)

\textbf{else if} $r \ge r_c$\textbf{:} search($r_\mathrm{up}$, $r$)

\caption{Binary search algorithm (\S~\ref{sec:remap.locate})}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[h]
\caption{Remap phase algorithm (\secstr~\ref{sec:remap.local})}

\KwIn{radius $r$ with $r_d < r < r_c$}

% $r_d \leftarrow r$\textbf{,} $r_c \leftarrow r$

% \textbf{while} $\Pi[r_c] \notin \Pii$\textbf{:}
% $r_c \leftarrow r_c + 1$\textbf{,} measure($r_c$)

% \textbf{while} $\Pi[r_d] \notin \Pii$\textbf{:}
% $r_d \leftarrow r_d - 1$\textbf{,} measure($r_d$)

\textbf{foreach} $r \in [r_d, r_c]$\textbf{:} measure($r$)

\textbf{if} $r_d \ne \Pii\langle \Pi[r_d]\rangle$\textbf{:}
search(0, $r_d$)

\textbf{foreach} $r > r_c$ measured\textbf{:}

\Indp
$h_r \leftarrow \Pi[r]$\textbf{,} $h_c \leftarrow \Pi[r_c]$

\mbox{\textbf{if} $r - r_c \ne \Pii\langle h_r\rangle -
\Pii\langle h_c\rangle$\textbf{:} search($r_c$, $r$)}

\end{algorithm}


